\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage{csvsimple}

\usepackage[brazil]{babel}    
\usepackage[utf8]{inputenc}
 
\sloppy

\title{Contagem do número de instruções dos \textit{benchmarks} do
\texttt{SPEC CPU2006} e implementação de uma \textit{pintool}}

\author{Gustavo Ciotto Pinton\inst{1} }


\address{Instituto de Computação -- Universidade Estadual de Campinas
(UNICAMP)\\
  Av. Albert Einstein, 1251, Cidade Universitária, Campinas/SP \\
  Brasil, CEP 13083-852 \\  Fone: [19] 3521-5838
  \email{ra117136@unicamp.br}
}

\begin{document} 

\maketitle

\begin{abstract}
This report describes the number of instructions executed by each
benchmark in \texttt{SPEC CPU2006}. It was achieved thanks to the
Intel's \texttt{pin} application. All results were obtained by running the
benchmarks with the \texttt{ref} inputs and a single iteration. A new
pin tool was equally developed, which lists the number of executed instructions
of every routine of all threads that compose the program. Five benchmarks,
run with inputs belonging to the \texttt{test} set, were used to test this new
tool.
\end{abstract}
     
\begin{resumo} 
Este relatório apresenta o número de instruções executadas por cada
\textit{benchmark} presente no \texttt{SPEC CPU2006}, calculado através da
utilização da ferramenta \texttt{pin}, desenvolvida pela Intel. Os valores
encontrados correspondem às entradas do tipo \texttt{ref} e a uma única
iteração. Além disso, desenvolveu-se uma nova \texttt{pin tool}, cuja saída
é a uma lista com o número de instruções executas pelas rotinas de um programa,
separadas pela sua respectiva \textit{thread}. Tal ferramenta foi testada em 5
benchmarks na configuração \texttt{test}.
\end{resumo}


\section{Introdução}

\texttt{SPEC}, do inglês \textit{Standard Performance Evaluation Corporation}, é
uma organização constituída por fabricantes de \textit{hardware},
\textit{software} e instuições de pesquisa, cujo objetivo é definir uma série de
testes relevantes e padronizados para a análise da performance de um computador.
Tais testes podem ser igualmente denominados de \textit{benchmarks} e visam
avalisar um aspecto específico de processamento. Durante a aula, vimos que
existe uma grande variedade de \textit{benchmarks} disponíveis na
\textit{internet}, sendo que alguns foram implementados, por exemplo, para
avaliar o desempenho de aplicações \textit{web}. Um \textit{benchmark} realiza
um conjunto de operações definidos, chamado de \textbf{workload}, e produz um
resultado, ou seja, uma \textbf{métrica} que tenta avaliar o desempenho do
computador submetido ao respectivo \textit{workload}. Tendo em vista tais
conceitos, o \texttt{SPEC CPU2006} é um conjunto de 31 \textit{benchmarks} que
procuram avaliar a performace de três componentes principais, sendo eles o
processador, a arquitetura de memória e os compiladores. Os \textit{benchmarks}
são distribuídos em dois \textit{suites}, denominados de \texttt{CINT2006} e
\texttt{CFP2006}, que se distinguem quanto à natureza do seu processamento
intensivo: o primeiro é focado na performance das operações que utilizam números
\textbf{inteiros}, sendo que o segundo, de números em \textbf{ponto flutuante}.
Essencialmente, \texttt{SPEC CPU2006} oferece duas métricas, \textbf{speed} e
\textbf{rate} (ou \textbf{throughput}), medindo, respectivamente, o quão rápido
um computador completa uma única tarefa e quantas tarefas tal sistema pode
realizar em um pequeno período de tempo. Cada métrica possui, por sua vez,
quatro \textit{variações}, que se diferenciam quanto ao \textit{suite} (inteiro ou
ponto flutuante) e ao método de compilação. Em relação a este último, duas
opções são disponibilizadas: \texttt{base}, que apresenta requisições mais
estritas, isto é, as \textit{flags} de compilação devem ser usadas na mesma
ordem para todos os \textit{benchmarks} de uma dada linguagem e é exigida para
um teste \textit{reportable} (execução que pode ser publicada), e \texttt{peak}, opcional
e com menos exigências.

\texttt{PIN}, por sua vez, é uma ferramenta para instrumentação e análise de
programas, à medida que ela permite a inserção de código dinamicamente ao
executável. Esta ferramenta é capaz de interceptar a execução da primeira
instrução e gerar um novo código a partir dela. Uma \texttt{pintool} pode ser
definida como uma extensão do processo de geração de código realizada pelo
\texttt{pin}, já que é capaz de interagir com este último e comunicar quais
funções, ou \textit{callbacks}, o aplicativo deve inserir ao código. De maneira
geral, uma \texttt{pintool} é composta por dois componentes, chamados de
\textit{instrumentation code} e \textit{analysis code}. O primeiro deve decidir
onde inserir o novo código, isto é, em que locais as rotinas de análise deverão
ser lançadas. É nessa fase, portanto, que características \textbf{estáticas} do
código, tais como, por exemplo nome de rotinas ou número de instruções que as
compõem, devem ser exploradas. O segundo, por sua vez, é chamado à medida que o
código é executado e, dessa forma, pode afetar significamente a performance de
um executável se o determinado código apresentar complexidade elevada. 

Neste relatório, será abordada, na primeira parte, o uso de uma \texttt{pintool}
para a avaliação do número de instruções executadas por cada um dos
\textit{benchmarks} e, em seguida, a implementação de uma nova ferramenta capaz
de determinar quantas instruções cada rotina de cada \textit{thread} foram
executadas.

\section{Contagem das instruções} \label{sec:count}


A fim de calcular as instruções de cada \textit{benchmark} do \texttt{SPEC
CPU2006}, dois \textit{scripts bash} foram implementados. O primeiro, chamado de
\texttt{run-pintool-all-benchmarks.sh} verifica e executa o \textit{runspec},
escrito em \textit{perl}, para cada um dos \textit{benchmarks}, além de compilar
a \textit{pintool} que será utilizada. Tal \textit{script} comunica alguns
parâmetros importantes ao comando \textit{runspec}, tais como o método de
compilação (\texttt{base}), o conjunto de entradas que será transmitido aos
programas (\texttt{ref}, no nossa caso), o número de iterações (1) e,
evidentemente, o nome do \textit{benchmark}. A execução deste comando produz um
arquivo de extensão \texttt{.tmp.log} no diretório do projeto, que é copiado
posteriormente a uma pasta, cujo nome é igual ao do
\textit{benchmark} que acabou de ser executado. O arquivo de configuração
transmitido ao comando \texttt{runspec} faz referência ao segundo \textit{script},
\texttt{run-spec-command.sh}, responsável por relacionar o aplicativo
\texttt{pin} com o respectivo \textit{benchmark}. Este \textit{script} recebe
como parâmetro o comando que o \texttt{SPEC} utiliza e o retransmite para o
\texttt{pin}, que é responsável por executá-lo efetivamente.

No manual de referência do \texttt{pin}, são indicadas quatro maneiras distintas
de se calcular o número de instruções executadas por um programa. A primeira,
\texttt{inscount0}, insere a rotina de análise antes de cada instrução,
produzindo, assim, uma grande perda de performance. A segunda,
\texttt{inscount1}, é superior à anterior, à medida que utiliza uma outra medida
de granularidade, chamado de \texttt{BBL} (do inglês, \textit{basic block}) e,
portanto, economiza diversas chamadas à função de análise. A terceira rotina,
chamada de \texttt{inscount2}, usa o mesmo princípio que a anterior, porém
apresenta melhor desempenho, visto que faz uso de dois recursos a mais que
\texttt{inscount1}. O primeiro recurso é a mudança de \texttt{IPOINT\_BEFORE}
para \texttt{IPOINT\_ANYWHERE}, que autoriza o \texttt{pin} escolher em que
ordem a função de análise é colocada, permitindo, assim, que ele escolha o ponto
que requeira mínimas operações de salvamento e restaturação dos registradores.
Além disso, esta ferramenta também usa a opção de \textit{fast call linkage},
que explora o fato de que alguns compiladores podem eliminar o
\textit{overhead} que, para funções pequenas como a a função de análise, é
comparável ao próprio conjunto de operações da respectiva função. Esta opção é
ativada através do uso de \texttt{PIN\_FAST\_ANALYSIS\_CALL}. Por fim, o último
programa utiliza, além dos recursos comentados anteriormente, uma unidade de
armazenamento rápido, chamado de \texttt{TLS}, indexado pelos \textit{indexes}
das \textit{threads} para gerar o número de instruções por \textit{thread}. 

Tendo em mente estas características, escolhe-se o programa
\textbf{\texttt{inscount2}} para o cálculo do número de instruções, visto que
este último apresenta o maior número de otimizações e que, neste contexto, não
visa-se encontrar uma contagem por \textit{threads}, mas sim global. Os
\textit{benchmarks} foram rodados em apenas um \textit{core} do processador
\textit{Intel i3} e levaram, ao todo, 20 horas aproximadamente. Os resultados
encontrados estão listados abaixo. Alguns \textit{benchmarks} possuem mais de
uma entrada e, portanto, produzem mais de uma saída. Tais saídas estão separadas
por \textit{vírgulas} na lista abaixo:

Para os \textit{benchmarks} do conjunto \textbf{inteiro}:
\begin {itemize}
\item \texttt{400.perlbench}: 1109198045367, 384794966182, 707786630157
\item \texttt{401.bzip2}: 432459815466, 181180973754, 309587458388,
553737482083, 605707320979, 345617094417
\item \texttt{403.gcc}: 77489490228, 151321617974, 139512528163, 103537789803,
113969504551, 154631785799, 183463430994, 169999746216, 58461954145
\item \texttt{429.mcf}: 341546845898
\item \texttt{445.gobmk}: 234525674455, 625631596347, 325147399858, 235593319559, 339210226918
\item \texttt{456.hmmer}: 971544939130, 2052353062674
\item \texttt{458.sjeng}: 2309967978778
\item \texttt{462.libquantum}: 2291912513237
\item \texttt{464.h264ref}: 500835844419, 355915755256, 3188039031373
\item \texttt{471.omnetpp}: 576122145483
\item \texttt{473.astar}: 411719281496, 829803428219
\item \texttt{483.xalancbmk}: 1048497777434
\end {itemize}

Para os \textit{benchmarks} do conjunto em \textbf{ponto flutuante}:

\begin {itemize}
\item \texttt{410.bwaves}: 2.495.514.310.671
\item \texttt{416.gamess}: 1124505753634, 878108843916, 3766238100560
\item \texttt{433.milc}: 1175358805504
\item \texttt{434.zeusmp}: 2016616007502
\item \texttt{435.gromacs}: 1971200720706
\item \texttt{436.cactusADM}: 2655006820074
\item \texttt{437.leslie3d}: 4626149683423
\item \texttt{444.namd}: 2361163844939
\item \texttt{447.dealII}: 1903231296730
\item \texttt{450.soplex}: 377431323949, 389903616072
\item \texttt{453.povray}: 1002529177253
\item \texttt{454.calculix}: 6894341894243
\item \texttt{459.GemsFDTD}: 2722715227347
\item \texttt{465.tonto}: 3563812458171
\item \texttt{470.lbm}: 1314569317678
\item \texttt{481.wrf}: 3867428098913
\item \texttt{482.sphinx3}: 3432419178361
\item \texttt{998.specrand}: 536611748
\item \texttt{999.specrand}: 536611748
\end{itemize}

Verifica-se, portanto, que o \textit{benchmark} que utiliza mais entradas em
seus testes é \texttt{403.gcc}, totalizando 1.152.387.847.873 instruções
executadas. Os \textit{benchmarks} que rodaram mais e menos instruções foram,
respectivamente, \texttt{454.calculix} e
\texttt{998.specrand}/\texttt{999.specrand}.


\section{Implementação de uma nova \textit{pin tool}} \label{sec:tool}

Tendo em vista que os programas apresentados na seção anterior não permitem a
contagem de instruções por rotina e por \textit{thread}, propõe-se a
implementação de uma nova \textit{pintool} contendo estas duas funcionalidades.
Para isso, utiliza-se a API da ferramenta para a adição de funções de
\textit{instrumentação} para cada routina e de \textit{análise} para suas
instruções. Além disso, faz-se uso do \textit{TLS} para a armazenagem de
informações específicas a uma \textit{thread}.

O registro da função de instrumentação é realizada através

\section{Conclusões}

% https://www.spec.org/cpu2006/Docs/readme1st.html#Q1

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}